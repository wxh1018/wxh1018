{"meta":{"title":"Wxh's blog","subtitle":"","description":"热爱前端开发的技术博客","author":"Wxh","url":"https://www.wxh520.xyz","root":"/"},"pages":[{"title":"","date":"2019-11-10T17:15:49.357Z","updated":"2019-11-10T17:15:49.357Z","comments":true,"path":"about/index.html","permalink":"https://www.wxh520.xyz/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 PHP，熟悉使用 Laravel、ThinkPHP 等主流框架；对 Modern PHP 情有独钟；有一定的代码洁癖。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：深圳 关于学习正在往终身学习者前进…近期学习方向：Python (人工智能) 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好热爱运动，尤其喜爱羽毛球、阅读、电影（Top250）、旅行。 联系我 Home: minhow.com Blog: blog.minhow.com Email: wxhmyq@gmail.com GitHub: MinHow WeiBo: MinHow Twitter: MinHow"},{"title":"tags","date":"2019-11-10T13:27:28.000Z","updated":"2019-11-10T15:06:30.199Z","comments":true,"path":"tages/index.html","permalink":"https://www.wxh520.xyz/tages/index.html","excerpt":"","text":""}],"posts":[{"title":"ajax，axios，fetch的区别","slug":"ajax,axios,fetch的区别","date":"2019-11-12T02:34:27.993Z","updated":"2019-11-12T02:40:28.191Z","comments":true,"path":"2019/11/12/ajax,axios,fetch的区别/","link":"","permalink":"https://www.wxh520.xyz/2019/11/12/ajax,axios,fetch%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"昨天同事和我探讨有关axios方面的问题，今天想了想把这3种方法总结一下 1.JQuery ajax12345678$.ajax(&#123; type: &apos;POST&apos;, url: url, data: data, dataType: dataType, success: function () &#123;&#125;, error: function () &#123;&#125;&#125;); 优缺点： 本身是针对MVC的编程,不符合现在前端MVVM的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） axios1234567891011121314axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); Vue2.0之后，尤雨溪推荐大家用axios替换JQuery ajax，想必让axios进入了很多人的目光中。axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征： 从浏览器中创建XMLHttpRequest（XHR—小黄人） 支持Promise API 客户端支持防止CSRF 提供了一些并发请求的接口（很重要，方便了很多的操作） 从node.js创建http请求 拦截响应和请求 转换请求和响应数据 取消请求 自动转换JSON数据 PS:防止CSRF:就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。 fetch1234567try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log(&quot;Oops, error&quot;, e);&#125; fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 fetch的优点: 1234567try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log(&quot;Oops, error&quot;, e);&#125; 符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里 更好更方便的写法 更加底层，提供的API丰富（request,response） 脱离了XHR，是ES规范里新的实现方式 1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理 2）fetch默认不会带cookie，需要添加配置项 3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费 4）fetch没有办法原生监测请求的进度，而XHR可以 总结：axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。","categories":[{"name":"数据请求","slug":"数据请求","permalink":"https://www.wxh520.xyz/categories/%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/"}],"tags":[{"name":"交互","slug":"交互","permalink":"https://www.wxh520.xyz/tags/%E4%BA%A4%E4%BA%92/"}],"author":"Wxh"},{"title":"JS原型,原型链","slug":"JS原型，原型链","date":"2019-11-11T14:19:46.949Z","updated":"2019-11-14T00:57:27.703Z","comments":true,"path":"2019/11/11/JS原型，原型链/","link":"","permalink":"https://www.wxh520.xyz/2019/11/11/JS%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"javascript原型、原型链？有什么特点每个函数都有一个==prototype==属性，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例原型 那么什么是原型呢？你可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 这是每一个javaScript对象（除了null）都具有的一个属性，叫proto,这个属性会指向该对象的原型。 原型链解决的主要是继承问题。每个对象拥有一个原型对象，通过proto指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，一样一层一层，最终指向null（Object.prototype.proto指向的是null）。这种关系被称为原型链（prototype chain），通过原型链一个对象拥有定义在其他对象中的属性和方法。 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://www.wxh520.xyz/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JS基础","slug":"JS基础","permalink":"https://www.wxh520.xyz/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS面试题","slug":"JS面试题总结","date":"2019-11-11T01:20:00.000Z","updated":"2019-11-11T15:19:26.142Z","comments":true,"path":"2019/11/11/JS面试题总结/","link":"","permalink":"https://www.wxh520.xyz/2019/11/11/JS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"一js基础1，this关键字的作用:***普通函数 window构造函数 当前构造函数创建的对象在new这个构造函数的时候 会在内存中创建一个对象，此时会让this指向刚创建好的这个对象方法中的this 方法所属的对象，谁调用这个方法this就指向谁函数处理函数中的this 事件源 谁调用的该事件 this就指向谁 2，call和apply的区别功能都一样，都是将当前函数作为指定对象的方法执行，即函数中的this是指对象call（this.Obj, arg1,arg2……）//将所有参数一个个的传递进去apply(this ,[argArray]) //将所有参数放在数组中传入 3.worker继承Person的方法//使用构造函数+原型的组合模式 1234567891011121314function Person(age,name)&#123; this.age = age; this.name = name&#125;Person.prototype.show = function()&#123; alert(&apos;父级方法&apos;)&#125;function Worker(age,name,job)&#123; Person.applay(this,arguments); this.job = job&#125;Worker.prototype = new Person()var Person = new Person(14,&apos;张三&apos;)var worker = new Worrker(25,&apos;里斯&apos;,&apos;程序员&apos;) 4.var let const的区别var 定义的变量，没有快的概念，可以跨块访问，不能跨函数访问let定义的变量，只能在块级作用域里访问，不能跨块访问，也不能跨函数访问const用来定义常量，使用时必须初始化（即必须赋值），只能在块作用域里访问，而且不能修改cookie4k 5m 5.如何阻止事件冒泡和事件默认行为//阻止事件冒泡if(typeof ev.stopPropagation == ‘function’){ ev.stopPropagtion()}else{//非标准 window.evnet.cancelBubble = true}//阻止事件默认行为return false 6.javascript的内置对象和宿主对象内置对象为Object,Array,Function,DateMath 等宿主为 浏览器自带的window等 7.“==”和”===”的不同前者会自动转换类型后者不会 8.浏览器的同源策略一段Ajax只能读取来自同一来源的窗口和文档的属性，这里的同意来源是指主机名，协议和端口号的组合 9.解释var a = null;alert(typeof a)//objectnull是只有一个值的数据类型 这个值就是null，表示一个空指针对象，所以用typeof检测会返回object 10. JavaScript的数据类型都有什么？基本数据类型：String,boolean,Number,Undefined, Null引用数据类型：Object, Array, Function原始数据类型：Symbol那么问题来了，如何判断某变量是否为数组数据类型？方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效方法二.obj instanceof Array 在某些IE版本中不正确null,array,object返回的都是‘object’ 11. 输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26var d = new Date();// 获取年，getFullYear()返回4位的数字var year = d.getFullYear();// 获取月，月份比较特殊，0是1月，11是12月var month = d.getMonth() + 1;// 变成两位month = month &lt; 10 ? ‘0’ + month : month;// 获取日var day = d.getDate();day = day &lt; 10 ? ‘0’ + day : day;alert(year + ‘-‘ + month + ‘-‘ + day); 12. 将字符串”{$id}{$name}”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）1&quot;&lt;tr&gt;&lt;td&gt;&#123;$id&#125;&lt;/td&gt;&lt;td&gt;&#123;$id&#125;_&#123;$name&#125;&lt;/td&gt;&lt;/tr&gt;&quot;.replace(/&#123;\\$id&#125;/g, &apos;10&apos;).replace(/&#123;\\$name&#125;/g, &apos;Tony&apos;); 13.var的变量提升底层原理是什么JS引擎的工作方式：先解析代码 获取所有声明的变量然后再运行 14.箭头函数的特点相比普通函数更简洁的语法本身没有this，捕获其所在上下文（作用域）的this值，作为自己的 this 值不能使用new不绑定arguments，用rest参数…解决使用call()和apply()调用箭头函数没有原型属性不能简单返回对象字面量箭头函数不能当做Generator函数,不能使用yield关键字 15. 为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义12345678910111213141516// let str = &apos;&gt;&amp;&amp;&apos;// function escapeHtml(str) &#123;// return str.replace(/[&lt;&gt;&amp;“]/g, match =&gt; &#123;// switch (match) &#123;// case &apos;&gt;&apos;:// return &apos;&amp;gt&apos;;// case &apos;&lt;&apos;:// return &apos;&amp;lt&apos;;// case &apos;&amp;&apos;:// return &apos;&amp;amp&apos;;// case &apos;\\&apos;&apos;:// return &apos;&amp;quot&apos;;// &#125;// &#125;)// &#125;// console.log(escapeHtml(str)); 16. foo = foo||bar ，这行代码是什么意思？为什么要这样写？如果foo存在，值不变，否则把bar的值赋给foo。短路表达式：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。 17 阻止事件冒泡和默认行为冒泡 :e.stopPropagation() e.cancelBubble = true;默认行为：e.preventDefault()e.returnValue = false 18.列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个对象：window, document, location, screen, history, navigator方法：alert(), confirm(), prompt(), open(), close() 19. Javascript如何实现继承？构造继承法2.原型继承法3.实例继承法 20，// push()：向数组的最后面插入一个或多个元素，返回结果为该数组新的长度。// pop()：删除数组中的最后一个元素，返回结果为被删除的元素。// unshift()：在数组最前面插入一个或多个元素，返回结果为该数组新的长度。插入元素后，其他元素的索引会依次调整。// shift()：删除数组中的第一个元素，返回结果为被删除的元素。 // 添加返回长度// 删除返回删除的元素 21，1. 判断一个字符串中出现次数最多的字符，统计这个次数123456789101112131415161718var str = &apos;asdfssaaasasasasaa&apos;;var json = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1; &#125;else&#123; json[str.charAt(i)]++; &#125;&#125;;var iMax = 0;var iIndex = &apos;&apos;;for(var i in json)&#123; if(json[i]&gt;iMax)&#123; iMax = json[i]; iIndex = i; &#125;&#125;alert(&apos;出现次数最多的是:&apos;+iIndex+&apos;出现&apos;+iMax+&apos;次&apos;); 22 闭包是什么，有什么特性，对页面有什么影响当内部函数使用了外部函数的局部变量时, 产生的一个对象(包含了所有使用了的变量) 作用: 在函数执行完后, 局部变量还会存在 12345678910function outer()&#123;var num = 1;function inner()&#123;var n = 2;alert(n + num);&#125;return inner;&#125;var r = outer();r(); 23 生成5个不同的随机数；//思路：5个不同的数，每生成一次就和前面的所有数字相比较，如果有相同的，则放弃当前生成的数字！ 123456789var num1 = [];for(var i = 0; i &lt; 5; i++)&#123; num1[i] = Math.floor(Math.random()*10) + 1; //范围是 [1, 10] for(var j = 0; j &lt; i; j++)&#123; if(num1[i] == num1[j])&#123; i--; &#125; &#125;&#125; 26.什么是js的严格模式 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，IE 10在内的主流浏览器“use strict”;//是进入严格模式的标志(老版本的浏览器会把它当作一行普通字符串，加以忽略。)27 浏览器标准模式和怪异模式之间的区别是什么？所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式 28你如何优化自己的代码？代码重用避免全局变量（命名空间。封闭空间。模块化mvc）拆分函数避免过于臃肿注释 29 请尽可能详尽的解释ajax的工作原理Ajax的工作原理相当于在用户和服务器之间加了—个中间层，使用户操作与服务器响应异步化。这样把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理，减轻服务器和带宽的负担，从而达到节约ISP的空间及带宽租用成本的目的。简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 二：Vue面试题30：谈下你对Vuex的认识vuex是什么，干嘛的，他的组成部分，每一部分是干嘛的，有啥有特点，你在项目中哪些数据让他管理 ，怎么管理，遇到过什么问题没 怎么处理的他就是状态管理模式，场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车state 进行组件共享数据的集中存储{}getters 原理 commputed 用于返回最新的数据值 {计算属性写法}mutations 唯一一个能够修改state里面数据的 地方（函数），不能做异步actions 处理异步请求 异步调用mutations 函数modules 模块 当数据比较多的情况下 而且数据之前灭有什么关系 用模块划分，每一个模块对象都包含以上4部分commit 同步调用actions方法dispatch 异步调用actions方法 31：防抖节流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647防抖：函数触发n秒后执行，如果在n秒之内触发 则重新计时// 假防抖let timer = nullfunction fd() &#123; clearTimeout(timer) timer = setTimeout(show, 1000)&#125;function show() &#123; console.log(input1.value);&#125;input1.oninput = function () &#123; fd(show)&#125;// 真防抖function fd2(fn, delay) &#123; let timer2 = null console.log(timer2) function a() &#123; console.log(timer2) clearTimeout(timer2) timer2 = setTimeout(fn, delay) &#125; return a&#125;function show2() &#123; console.log(input2.value);&#125;input2.oninput = fd2(show2, 500)节流：在n秒内只触发一次函数，n秒内多次触发只有一次生效input3.oninput = jl()function jl() &#123; let timer3 = null; return function () &#123; if (!timer3) &#123; timer3 = setTimeout(() =&gt; &#123; show3() timer3 = null; &#125;, 1000) &#125; &#125;&#125;function show3() &#123; console.log(input3.value);&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://www.wxh520.xyz/categories/JS/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.wxh520.xyz/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"基础","slug":"基础","permalink":"https://www.wxh520.xyz/tags/%E5%9F%BA%E7%A1%80/"}],"author":"WXH"},{"title":"Vue遇到的各种问题","slug":"Vue遇到的各种问题","date":"2018-05-23T04:47:45.000Z","updated":"2019-11-16T01:01:58.236Z","comments":true,"path":"2018/05/23/Vue遇到的各种问题/","link":"","permalink":"https://www.wxh520.xyz/2018/05/23/Vue%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/","excerpt":"","text":"原理1.你知道vue的模板语法用的是哪个web模板引擎的吗？说说你对这模板引擎的理解. 1mustache，主要是使用&#123;&#123;&#125;&#125;进行数据渲染。 2.你知道v-model的原理吗？那双向绑定的原理呢？ 1234v-model是一个语法糖，真正实现双向绑定还是依靠v-bind：绑定响应式数据。以及触发input事件并传递数据（核心和重点）双向绑定的原理：通过Observer把数据劫持（Object.defineProperty()），加入到订阅器（Dep）,订阅器收集订阅者（watch），视图通过编译（Compile）解析指令（Directive）等一系列操作收集给订阅者，最后通过触发数据变化update通知所有的订阅者完成数据驱动。直白的理解为：Object.defineProperty()重新定义了set和get方法，修改触发set方法赋值。获取触发get方法取值，并通过数据劫持发布信息。 3.你知道vue中key的原理吗？说说你对它的理解 1便于diff算法的更新，key的唯一性，能让diff算法更快的找到需要更新的dom节点。 4.Vue.Observable你有了解过吗？ 12vue2.6发布的一个新的api，可以处理简单的跨组件共享数据状态的问题。精简版的vuex。 5.你知道style加scoped属性的用途和原理吗？ 121.用途：防止全局同名css污染。2.原理：在标签上添加v-data-something属性，再在选择器加上对应[v-data-something],即css带属性选择器，以此完成类似作用域的选择方式。 6.$nextTick的作用 123456789101112// 官方文档：下次DOM更新循环结束执行延迟回调，在修改数据之后立刻调用这个方法，就会获取更新后的DOM。//什么时候用到Vue.$nextTick();//1.created初始化状态的时候没有挂载dom元素，所以此时需要操作dom元素就必须使用$nextTick();//2.mounted不会承诺所有的子组件也都一起被挂载，如果你希望等到整个视图都渲染完毕，可以用$nextTick()替换mounted。mounted:function()&#123; this.$nextTick(()=&gt;&#123; &#125;)&#125; 文件路径1.怎么解决vue打包后静态资源图片失效的问题？，那又怎么解决动态设置img的src不生效呢？ 1231.找到config/index.js配置文件，找到build打包对象里的assetsPublicPath属性，将默认值：&apos;/&apos;，修改为：&apos;./&apos;。2.因为动态添加的src被当做静态资源处理了，没有进行编译，所以要加上require。&lt;img :src=&quot;require(&apos;@/assets/images/xxx.png&apos;)&quot; /&gt; 2.分析下vue项目本地开发完后部署到服务器后报404是什么原因？ 121.检查nginx（服务器）配置，是否正确配置资源映射条件。2.检查vue.config.js中是否配置了pubilcPath属性，检查是否和项目资源文件在服务器摆放的位置一样。 3.在vue项目中如何配置favicon？ 121.在html中添加mate标签2.在vue-cil中开发环境webpack.dev.config.js中配置，和生产环境webpack.prod.config.js中配置。 4.使用vue后怎么针对搜索引擎做SEO优化？ 1使用服务端渲染，vue官方推荐nuxt.js 生命周期1.Vue生命周期可以分为几个阶段？ 1234567898个阶段1.beforeCreate：创建前,（data和methods都没初始化）2.created：创建后，(data和methods已经初始化)3.beforeMount：载入前,（在内存中已经编译好了模板，但是还没有挂载到页面上，dom还没有生成）4.mounted：载入后,（Vue实例已经初始化完成了，此刻dom已经生成）5.beforeUpdate：更新前,（此刻页面的数据是旧的，data的数据是更新的了，也就是页面还没有和最新的数据同步）6.updated：更新后（页面的数据已经和更新的数据同步了）,7.beforeDestroy：销毁前（此刻data，mothods，指令，过滤器都处于可用状态）,8.destroyed：销毁后（此刻所有的data，mothods，指令等等，都处于不可用状态） 2.Vue在created和mounted这两个生命周期中请求的数据有什么区别？ 121.在created请求时，是在页面渲染出来之前做的事情，如果数据过大，可能造成页面白屏过久，因为created还没有dom元素生成。并且也不能操作dom元素2.在mounted请求时，是在页面渲染出来之后做的事情，此时可以操作dom元素。 3.跟keep-alive有关的生命周期是哪些？描述下这些生命周期 121.activated： 页面第一次进入的时候，钩子触发的顺序是created-&gt;mounted-&gt;activated2.deactivated: 页面退出的时候会触发deactivated，当再次前进或者后退的时候只触发activated 4.第一次加载页面时会触发哪几个钩子？ 12341.beforeCreate2.created3.beforeMount4.mounted 组件1.如何通过子组件访问父组件的实例 12this.$parent :拿到父组件的实例this.$children拿到子组件实例（数组） 2.如何访问子组件的实例或者子元素 123456//父组件&lt;template&gt; //给子组件绑定ref属性 &lt;base-alert ref=&quot;baseAlert&quot;&gt;&lt;/base-alert&gt;&lt;/template&gt;使用this.$refs.baseAlert获取到子组件，并且可以调用子组件this.$refs.baseAlert.add()方法。 3.vue怎么实现强制刷新组件？ 12345678910//强制刷新某组件&lt;SomeComponent :key=&apos;theKey&apos;&gt;//选项里绑定datadata()&#123; return&#123; theKey:0 &#125;&#125;//刷新key达到刷新组件的目的theKey++; 4.vue自定义事件中父组件如何接收子组件的多个参数？ 123456//子组件提交多个参数var data = &#123; &apos;name&apos;:&apos;1&apos;, &apos;name2&apos;:&apos;2&apos;&#125;this.$emit(&apos;func&apos;,data) 5.vue给组件绑定自定义事件无效怎么解决？ 1234561、组件外部加修饰符：.native//父组件&lt;div&gt; &lt;my-children @click.native=&apos;onClick&apos;&gt;&lt;/my-children&gt;&lt;/div&gt;2、组件内部添加$emit()方法提交事件 6.vue如果想扩展某个现有的组件时，该怎么做？ 12341.使用slot插槽。2.使用mixin混入。3.使用vue.extends直接扩展。(优先级比mixin高)4.使用HOC高阶组件。 7.vue为什么要求组件模板只能有一个根元素？ 123就像一个HTML文档只能有一个根元素一样....多个根元素必将导致无法构成一颗树所以解释了 &lt;template&gt;&lt;/template&gt;只有一个&lt;div&gt;根元素。 8.vue中什么是递归组件？ 1234567891011121314//当前注册一个vue组件定义 name 为 &apos;node-tree&apos; ，在组件 template 内部调用 实现递归。//tree.vue&lt;template&gt; &lt;template v-for=&quot;item in parentItem.list&quot;&gt; &lt;node-tree v-if=&quot;item.list&amp;&amp;item.list.length!==0&quot; :parent-item=&quot;item&quot; &gt; &lt;!--无限递归，--&gt; &lt;/node-tree&gt; &lt;/template&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:&apos;nodeTree&apos;, &#125;&lt;/script&gt; 9.vue边界情况有哪些？ 1234567891011121.访问元素&amp;组件 访问根实例 访问父组件实例 访问子组件实例或子元素 依赖注入2.程序化的事件侦听器 $on(event,,,) ：侦听一个事件 $once(event,,,)：一次性侦听一个事件 $off(event,,,)：停止侦听一个事件3.循环引用 3.1：递归组件 3.2：组件之间的循环引用 10.vue组件中定时器要怎么销毁？ 123const time = setInterval(()=&gt;&#123; //do.somthing&#125;,500) 1234//通过$once监听定时器，在beforeDestroy钩子可以被清除。this.$once(&apos;hook:beforeDestroy&apos;,()=&gt;&#123; clearInterval(time)&#125;) 11.vue组件会在什么情况下被销毁？ 1在组件中使用v-if的时候。 12.vue组件里写的原生addEventListeners监听事件，可以用手动销毁吗？为什么？ 1可以用手动销毁，因为一方面是绑定多次，另一方面是函数没有释放会造成内存溢出。 13.你了解函数式组件吗？ 123需要提供一个render方法，接收一个参数（createElement函数）,方法内根据业务逻辑写需求，createElement创建vnodes，最后return vnodescreateElement函数接收三个参数，1：html标签或自定义组件。2：一个object（包含props，on...等等），3:children（通过createElement构建，或者字符串） 问题知识点-HTML1.Vue渲染模板时怎么保留模板中的HTML注释呢? 1234//模板标签添加 comments 属性&lt;template comments&gt; ...&lt;/template&gt; 2.如何修改分隔符”&lt;!–￼53–&gt;”? 12345678//对于laravel+vue开发已经成为常态(php)，laravel框架开发下我们的分隔符&quot;&#123;&#123;&#125;&#125;&quot;是和vue+webapck+node是一样的。所以我们要修改我们的分隔符。var vm =new Vue(&#123; el:&quot;app&quot;, delimiters:[&apos;$&#123;&apos; , &apos;&#125;&apos;], //修改定界符&apos;&#123;&#123;&#125;&#125;&apos;; data()&#123;&#125;&#125;)//最后laravel框架下的分割符变成了$&#123;&#125; 3.slot（插槽）的理解有多少？ 123456789101112//插销显示与否：应根据父组件在引入子组件时，子组件中是否存在模板。1.匿名插槽：在父组件中只能出现一个。2.具名插槽：在父组件中可以出现多个3.作用于插槽：在插槽中要绑定数据，&lt;slot name=&quot;up&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt; export default &#123; data: function()&#123; return &#123; data: [&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wanwu&apos;,&apos;zhaoliu&apos;,&apos;tianqi&apos;,&apos;xiaoba&apos;] &#125; &#125;, 4.如何优化首页的加载速度？ 1231.http请求控制次数。2.异步加载数据，异步路由。3.分屏加载，按需加载，延迟加载图片，cdn静态资源缓存。 问题知识点-CSS 1.Vue的：class和;style有几种表达方式？ 12:class 绑定变量，绑定对象，绑定一个数组，绑定三元运算符:style 绑定变量，绑定对象，绑定函数返回值，绑定三元运算符 问题知识点-JS1.Vue中怎么重置data 12341.Object.assign()方法：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。2.this.$data：获取当前状态下的data。3.this.$option.data：获取该组件初始化状态下的data。4.Object.assign(this.$data,this.$option.data); 2.watch的属性用箭头函数定义结果会怎么样？ 1this为undefined，因为箭头函数绑定了父级作用域的山下文，所以this将不会按照期望指向vue实例。 3.在vue项目中如果methods的方法用箭头函数定义结果会怎么样？ 1因为箭头函数默认绑定了父级作用域的上下文，所以this将不会绑定vue实例，所以this是undefined。 4.你有使用过babel-polyfill模块吗？主要是用来做什么的？ 1babel默认只进行转换语法，而不转换新的api。所以想要转换新的api还需要对应的转换插件。或者使用polyfill模拟新api。 5.说说你对vue的错误处理的了解？ 123vue错误处理有两种，1.errorCaptured：是组件内部钩子，可以捕获到本组件以及子孙组件抛出的错误，接收参数有error，vm，info三个参数，return false后可以阻止错误继续向上抛出、2.errorHandler：为全局钩子，使用vue.config.errorHandler配置，接收参数和errorCaptured一致，2.6后可捕获v-on与promise链的错误，可用于统一错误处理与错误兜底。 在vue事件中传入$event，使用e.target和e.currentTarget有什么区别？ 12e.target：属于事件发生者（鼠标触发的元素）e.currentTarget：属于事件绑定的元素。 7.vue变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？ 12以_或者$开头的属性 不会被vue实例代理，因为它们可能会和vue内置属性，api方法冲突，我们可以使用vm.$data._property的方式访问这些属性 8.vue使用v-for遍历对象时，是按照什么顺序遍历的？如何保证顺序？ 1231.会先判断对象是否存在iterator接口，如果有循环执行next()方法。2.没有iterator的情况下，会调用Object.Keys()方法，在不同的浏览器中，js引擎不能保证输出的顺序是一致的。3.如果想要保证输出的顺序一致，可以将对象放进数组中，作为数组的元素。 9.说下$attrs和$listeners的使用场景 12$attrs：获取父级以上的所有（非props属性）的属性。$listeners：调用在父级以上的所有定义的方法。 10.EventBus事件总线注册在全局上时，路由切换的时候重复触发事件，该如何解决呢？ 12345678910111213141516171819202122232425262728291、EventBus的使用//创建EventBusimport Vue from &apos;vue&apos;export default new Vue;2、在main.js导入eventbus，然后挂载在vue原型上import bus from &apos;./utils/eventBus&apos;;Vue.prototyle.bus = bus;3、发送事件//在触发事件的地方发送事件this.bus.$emit(this.$route.path);$emit()里面接收一个string字符串事件名，4、接收事件//事件已经发送，接下来只需要在需要接收事件的地方接收这个事件，然后对事件进行响应就可以了。this.bus.$on(this.$route.path,()=&gt;&#123; this.getData();&#125;)//接收事件同样需要一个事件名。5、事件重复触发的问题 //我们只需要在组件的beforeDestroy或者destroy生命周期中执行销毁方法。beforeDestroy()&#123; this.bus.$off(this.$route.path)&#125;6、如果使用this.$route.path作为事件名，那么虽然我们在生命周期注销了事件，但是还是发现事件会执行多次，原因在于我们在beforeDestroy中，this.$router.path根本不是我们发送和响应事件时候的路由了，而是将要跳转的页面路由。所以只要我们在当前页面用一个变量将当前路由存下来。用这个变量作为变量名注销事件即可。 11.Vue组件中写name选项有什么作用？ 1231.使用keep-alive时，可以搭配组件name进行缓存过滤2.DOM做递归组件时需要调用自身name。3.vue-devtools调式工具里显示的组件名称是有vue中name决定的 12.Vue中的provide和inject是什么？ 12provide：是一个对象，或者是返回对象的函数，里面包含要给子孙后代的东西，也就是属性和属性值。（不再需要逐级往上找值）inject：是一个字符串数组，或者是一个对象，属性值可以是一个对象，包含from，和default默认值。 13.v-if和v-for同时出现的优先级问题？ 12345//v-for的优先级比v-if高。所以同时出现的时候，先给v-for套一层template作为父级元素，再在父级元素进行v-if判断&lt;template v-if&gt; &lt;div v-for&gt;&lt;/div&gt;&lt;template&gt; 指令与修饰符1.v-once的使用场景有哪些？ 1表单提交，可防止用户在请求未响应时再次点击多次触发。 2.vue修饰符.lazy的理解？ 1由input事件改变为change事件。 3.常用的指令 121.v-if 、2.v-for、3.v-on、4.v-bind、5.v-once 、6.v-foucs、7.v-blur、8.v-model、 9.v-hide、10.v-show 4.v-cloak和v-pre指令的理解 1.v-cloak：是指在HTML渲染之前定义的一个指令属性，通常用于解决网络延迟页面显示Vue源码的问题。 12345678&lt;div id=&apos;app&apos; v-cloak&gt; &#123;&#123;context&#125;&#125;&lt;/div&gt;//CSS[v-cloak]&#123; display：none；//隐藏&#123;&#123;context&#125;&#125;源码的显示。&#125; 2.v-pre：跳过添加v-pre指令的元素以及它的所有子元素的编译过程。 12&lt;span v-pre&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;//即使在data定义了msg，这里仍然会在页面显示&#123;&#123;msg&#125;&#125; 5.指令的钩子有哪些？ 123451.bind：只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性初始化设置2.inserted：被绑定元素插入父节点时调用（仅保证父节点的存在，但不一定已被插入文档中）3.update：所在组件的VNode更新时调用。但是可能发生在其子VNode更新之前。指令的值可能发生了变化。也可能没有。4.componentUpated：指令所在的组件的VNode及其子VNode全部更新后调用。5.unbind：只调用一次，指令与元素解绑时调用 6.prevent.self与self.prevent的先后顺序问题 1234567891011121314151617//prevent.self 阻止元素所有自身的点击事件&lt;div @click=&quot;fun()&quot;&gt; &lt;a href=&quot;@/pages/home/homeIndex&quot; @click.prevent.self=&quot;fun1()&quot;&gt; &lt;span v-on:click=&quot;fun2()&quot;&gt;sapn标签&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;//点击span标签 会触发fun2和fun函数 但是 a标签所有的事件都不会触发，包括链接跳转//self.prevent 阻止元素自身的点击事件&lt;div @click=&quot;fun()&quot;&gt; &lt;a href=&quot;@/pages/home/homeIndex&quot; @click.self.prevent=&quot;fun1()&quot;&gt; &lt;span v-on:click=&quot;fun2()&quot;&gt;sapn标签&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;//点击span标签 会触发fun2和fun函数 但是 a标签自身的点击事件不会触发，而会触发链接跳转","categories":[{"name":"vue","slug":"vue","permalink":"https://www.wxh520.xyz/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.wxh520.xyz/tags/vue/"}]},{"title":"MiHo-主题安装和配置详情","slug":"installation-configuration","date":"2018-03-05T16:00:00.000Z","updated":"2019-11-16T00:59:55.415Z","comments":true,"path":"2018/03/06/installation-configuration/","link":"","permalink":"https://www.wxh520.xyz/2018/03/06/installation-configuration/","excerpt":"","text":"一. 主题简介&emsp;&emsp;MiHo 是一款单栏响应式的Hexo主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在GitHub上，欢迎Star和Fork；如遇到问题或发表建议，可以提Issues，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。 二. 安装2.1 安装主题1$ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho MiHo 主题需要Hexo 3.0或以上版本，请先升级。 2.2 更新12cd themes/mihogit pull 2.3 依赖安装如下依赖如果已经安装，请看配置介绍。 Json-content生成站点文章静态数据，用于站内搜索。 1npm install hexo-generator-json-content --save 三. 站点配置站点配置文件_config.yml在hexo根目录下。 3.1 启用主题1`theme: miho` 3.2 网站基本配置以下配置是站点的全局配置，更多配置，请查看 123456title: MinHow's Blogsubtitle: 网站副标题description: 专注 WEB 开发的技术博客author: MinHowlanguage: 网站使用的语言timezone: 网站时区 3.3 jsonContent配置详细的配置请查看hexo-generator-json-content 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false 四. 主题配置编辑主题配置文件，themes/miho/_config.yml。 4.1 属性下面将介绍几个比较重要的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122# hexo-theme-miho# https://github.com/wongminho/hexo-theme-miho# Favicon of your site | 网站iconfavicon: /favicon.ico# Header# Keywords of your site | 网站关键字keywords: MinHow,MinHow's Blog# Head headline | 头部标题header_title: MinHow's Blog# Head description | 头部描述header_description: 一个专注 WEB 开发的技术博客# Link to your logo | logo地址logo: images/logo.png# Link to your banner_img | 首页banner图地址banner_img: images/banner.jpg# Menu setting | 菜单设置# name: Font Awesome icon | Font Awesome 图标# title: Home Title | 标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出menu: home: title: Home url: / target: false archive: title: Archives url: /archives target: false user: title: About url: /about target: false# Social setting, use to display social information | 社交设置，用来展示社交信息# name: Font Awesome icon | Font Awesome 图标# title: Home Icon title | 图标标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出social: home: title: MinHow url: //minhow.com target: true github: title: Github url: //github.com/wongminho target: true weibo: title: Weibo url: //weibo.com/WongMinHo target: true twitter: title: Twitter url: //twitter.com/huangminhow target: true #qq: #weixin: #snapchat: #telegram: #mail: #facebook: #google: #linkedin:# Content# Excerpt length | 摘录长度excerpt_length: 190# Excerpt link | 摘录链接excerpt_link: more&gt;&gt;# New window open link | 新窗口打开文章open_new_link: false# Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150cover_picture: images/banner.jpg# Open background particles | 开启背景粒子open_bg_particle: true# Open animation in homepage and head | 开启主页及头部动画open_animation: true# Article# Open toc | 是否开启toctoc: true# Open share | 是否开启分享share: true# Style customization | 样式定制style: # Main color tone | 主色调 main_color: '#0cc'# Comments | 评论# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false# Analytics | 分析# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google analytics | google分析google_analytics: false# Footer# Access statistics | “不蒜子”访问量统计access_counter: on: true site_uv: 总访客数： site_pv: 总访问量：# Copyright Information | 版权信息copyright: 2017 MinHow 4.2 文章封面图文章默认封面图，尺寸：350*150，当文章基本配置没有cover_picture时才显示。 1cover_picture: images/banner.jpg 4.3 开启背景粒子是否开启背景粒子。 1open_bg_particle: true 4.4 开启主页及头部动画是否开启主页及头部动画。 1open_animation: true 4.5 评论支持畅言、disqus。 1234567# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false 4.6 数据统计支持站长、百度、google三种数据统计，正确填写配置信息即可。 123456# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google分析google_analytics: false 4.7 文章基本配置123456789101112---title: Hello Worlddate: 2017-06-18categories: Firstauthor: MinHowtags: - First - Secondcover_picture: /images/banner.jpg--- MinHow-This is a summary&lt;!-- more --&gt; 说明： 需要注意tags和摘要的写法，不然首页不能正确显示标签和摘要； cover_picture文章封面图，不填默认显示_config.yml配置的图片。","categories":[{"name":"开项目","slug":"开项目","permalink":"https://www.wxh520.xyz/categories/%E5%BC%80%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.wxh520.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"开源项目","slug":"开源项目","permalink":"https://www.wxh520.xyz/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}],"author":"MinHow"},{"title":"post_name","slug":"test","date":"2018-01-14T01:02:52.000Z","updated":"2019-11-21T15:28:51.313Z","comments":true,"path":"2018/01/14/test/","link":"","permalink":"https://www.wxh520.xyz/2018/01/14/test/","excerpt":"","text":"test","categories":[],"tags":[]},{"title":"js中的new()到底做了些什么？？","slug":"js继承","date":"2017-10-09T07:24:36.000Z","updated":"2019-11-21T15:28:48.367Z","comments":true,"path":"2017/10/09/js继承/","link":"","permalink":"https://www.wxh520.xyz/2017/10/09/js%E7%BB%A7%E6%89%BF/","excerpt":"","text":"js中的new()到底做了些什么？？要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4个步骤：(1) 创建一个新对象；(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；(3) 执行构造函数中的代码（为这个新对象添加属性） ；(4) 返回新对象。 new 操作符在有上面的基础概念的介绍之后，在加上new操作符，我们就能完成传统面向对象的class + new的方式创建对象，在JavaScript中，我们将这类方式成为Pseudoclassical。基于上面的例子，我们执行如下代码 var obj = new Base(); 这样代码的结果是什么，我们在Javascript引擎中看到的对象模型是： new操作符具体干了什么呢?其实很简单，就干了三件事情。 var obj = {};obj.proto = Base.prototype;Base.call(obj); 第一行，我们创建了一个空对象obj第二行，我们将这个空对象的proto成员指向了Base函数对象prototype成员对象第三行，我们将Base函数对象的this指针替换成obj，然后再调用Base函数，于是我们就给obj对象赋值了一个id成员变量，这个成员变量的值是”base”，关于call函数的用法。 如果我们给Base.prototype的对象添加一些函数会有什么效果呢？例如代码如下： Base.prototype.toString = function() { return this.id;} 那么当我们使用new创建一个新对象的时候，根据proto的特性，toString这个方法也可以做新对象的方法被访问到。于是我们看到了： 构造子中，我们来设置‘类’的成员变量（例如：例子中的id），构造子对象prototype中我们来设置‘类’的公共方法。于是通过函数对象和Javascript特有的proto与prototype成员及new操作符，模拟出类和类实例化的效果。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://www.wxh520.xyz/tags/JS/"}]}]}